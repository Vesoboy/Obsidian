### 1. Из каких подмножеств состоит SQL?

_Ответ_:

- DDL (Data Definition Language, язык описания данных) — позволяет выполнять различные операции с базой данных, 
такие как CREATE (создание), ALTER (изменение) и DROP (удаление объектов).

- DML (Data Manipulation Language, язык управления данными) — позволяет получать доступ к данным и манипулировать ими, 
например, вставлять, обновлять, удалять и извлекать данные из базы данных.

- DCL (Data Control Language, язык контролирования данных) — позволяет контролировать доступ к базе данных. 
Пример — GRANT (предоставить права), REVOKE (отозвать права).

---

### 2. Что подразумевается под СУБД? Какие существуют типы СУБД?

_Ответ_:

База данных — структурированная коллекция данных.
Система управления базами данных (СУБД) — программное обеспечение, которое взаимодействует с пользователем, 
приложениями и самой базой данных для сбора и анализа данных. СУБД позволяет пользователю взаимодействовать 
с базой данных. Данные, хранящиеся в базе данных, могут быть изменены, извлечены и удалены. 
Они могут быть любых типов, таких как строки, числа, изображения и т. д.

Существует два типа СУБД:

- Реляционная система управления базами данных: данные хранятся в отношениях (таблицах). Пример — PostgreSQL.
- Нереляционная система управления базами данных: не существует понятия отношений, кортежей и атрибутов. Пример — Mongo.

---

### 3. Что подразумевается под таблицей и полем в SQL?

_Ответ_:

#### Таблица

Таблица — это структура, которая хранит данные в виде строк и столбцов. Каждая таблица в базе данных имеет уникальное имя и состоит из:

• Строки (или записей): Каждая строка представляет собой отдельный экземпляр данных. Например, 
если у вас есть таблица "Пользователи", каждая строка может представлять отдельного пользователя.

• Столбцы (или поля): Каждый столбец в таблице представляет собой атрибут или характеристику данных. 
Например, в таблице "Пользователи" могут быть столбцы "ID", "Имя", "Email" и "Дата рождения".

Пример таблицы "Пользователи":

| ID | Имя     | Email               | Дата рождения |
|----|---------|---------------------|---------------|
| 1  | Иван    | ivan@example.com    | 1990-01-01    |
| 2  | Анна    | anna@example.com    | 1992-02-02    |
| 3  | Сергей  | sergey@example.com  | 1985-03-03    |

#### Поле

Поле — это отдельный элемент данных в таблице, который соответствует одному из столбцов. 
Поле представляет собой конкретное значение для определенной записи. Например, в строке 
с данными о пользователе "Иван" поле "Имя" будет содержать значение "Иван", а поле "Email" будет содержать значение "ivan@example.com".

Каждое поле имеет:

• Имя: Уникальное имя в пределах таблицы, которое используется для обращения к этому полю.

• Тип данных: Определяет, какой тип данных может храниться в этом поле (например, текст, число, дата и т.д.).

• Ограничения: Условия, которые определяют допустимые значения для этого поля (например, уникальность, обязательность заполнения и т.д.).

▎Пример определения таблицы

Вот пример SQL-запроса для создания таблицы "Пользователи":

```sql
CREATE TABLE Пользователи (
ID INT PRIMARY KEY,
Имя VARCHAR(50),
Email VARCHAR(100),
Дата_рождения DATE
);
```

В этом примере:

• ID, Имя, Email и Дата_рождения — это поля (столбцы) таблицы.

• INT, VARCHAR, и DATE — это типы данных для соответствующих полей.

---

### 4. Что подразумевается под целостностью данных?

_Ответ_:

Целостность данных — это концепция, которая гарантирует, что данные в базе данных остаются точными, 
последовательными и надежными на протяжении всего их жизненного цикла. Целостность данных включает в себя несколько ключевых аспектов:

1. **Согласованность** (Consistency): Данные должны соответствовать заданным правилам и ограничениям. 
Например, если в базе данных есть ограничения на уникальность для определенного поля, то никакие два значения не могут быть одинаковыми.

2. **Точность** (Accuracy): Данные должны быть корректными и отражать реальное состояние дел. 
Это означает, что данные должны вводиться и обновляться правильно.

3. **Полнота** (Completeness): Все необходимые данные должны быть собраны и храниться в базе данных. 
Отсутствие критически важных данных может привести к неправильным выводам и решениям.

4. **Атомарность** (Atomicity): Операции с данными должны быть неделимыми. Если одна часть операции 
не может быть выполнена, то вся операция должна быть отменена. Это особенно важно в контексте транзакций.

5. **Изолированность** (Isolation): Параллельные транзакции не должны влиять друг на друга. 
Это помогает предотвратить ситуации, когда одна транзакция может повлиять на результат другой.

6. **Долговечность** (Durability): После того как транзакция была завершена, изменения должны сохраняться 
даже в случае сбоя системы. Это гарантирует, что данные не потеряются.

7. **Целостность ссылок** (Referential Integrity): Это правило обеспечивает правильные связи между 
таблицами в реляционных базах данных. Например, если одна таблица ссылается на другую, то все ссылки должны быть корректными и существующими.

---

### 5. Что такое сущности и отношения?

_Ответ_:

#### Сущности

**Сущность** — это объект или понятие, которое можно однозначно идентифицировать и о котором можно собирать данные. 
Сущности могут быть как физическими (например, "Клиент", "Продукт"), так и абстрактными (например, "Заказ", "Транзакция"). 
Каждая сущность имеет атрибуты, которые описывают её характеристики. Например:

• Сущность "Клиент" может иметь атрибуты: имя, адрес, номер телефона и электронная почта.

• Сущность "Продукт" может иметь атрибуты: название, цена, категория и количество на складе.

#### Отношения

Отношение — это связь между двумя или более сущностями. Отношения описывают, как сущности взаимодействуют друг с другом. 
В реляционных базах данных отношения могут быть различных типов:

1. Один к одному (1:1): Каждая запись в одной сущности соответствует ровно одной записи в другой сущности. 
Например, один клиент может иметь только одну учетную запись.

2. Один ко многим (1:N): Одна запись в одной сущности может соответствовать нескольким записям в другой сущности. 
Например, один клиент может размещать множество заказов.

3. Многие ко многим (M:N): Записи в одной сущности могут соответствовать множеству записей в другой сущности и наоборот. 
Например, студенты могут записываться на множество курсов, а курсы могут иметь множество студентов.

▎Пример

Представим себе систему управления библиотекой:

_Сущности_:

• Книга (атрибуты: название, автор, ISBN)

• Читатель (атрибуты: имя, адрес, номер телефона)


_Отношения_:

• Читатель может взять несколько книг (отношение "один ко многим").

• Книга может быть взята несколькими читателями (отношение "многие ко многим").

---

### 6. Что такое свойство ACID в базе данных?

_Ответ_:

**ACID** — это набор свойств, который обеспечивает надежность и целостность транзакций в реляционных базах данных. 
ACID является акронимом, состоящим из четырех ключевых свойств:

1. **Atomicity** (Атомарность):

   • Это свойство гарантирует, что каждая транзакция рассматривается как единое целое. 
   Если одна часть транзакции не может быть выполнена, то вся транзакция отменяется, и база данных возвращается 
   в предыдущее состояние. Это предотвращает частичное выполнение операций, которые могут привести к неконсистентности данных.

2. **Consistency** (Согласованность):

   • Согласованность гарантирует, что транзакция переводит базу данных из одного согласованного состояния в другое. 
   Это означает, что все правила и ограничения базы данных (например, уникальность, целостность ссылок) должны соблюдаться до и после выполнения транзакции.

3. **Isolation** (Изолированность):

   • Изолированность обеспечивает, что выполнение одной транзакции не влияет на выполнение других транзакций. 
   Даже если несколько транзакций выполняются одновременно, каждая из них должна считаться изолированной от других. 
   Это достигается с помощью механизмов блокировки и управления конкурентным доступом.

4. **Durability** (Долговечность):

   • Долговечность гарантирует, что после завершения транзакции изменения, внесенные в базу данных, 
   сохраняются даже в случае сбоя системы. Это достигается путем записи изменений на постоянные носители 
   (например, жесткие диски) или использования журналов транзакций.

▎Пример

Рассмотрим пример банковской операции:

• Если клиент переводит деньги с одного счета на другой, это включает две операции: списание денег с одного счета и зачисление на другой.

• Атомарность: Если одна из операций (списание или зачисление) не может быть выполнена, обе операции отменяются.

• Согласованность: После завершения операции сумма денег в системе должна оставаться постоянной — деньги не могут исчезнуть или появиться ниоткуда.

• Изолированность: Если два клиента одновременно пытаются перевести деньги на один и тот же счет, их 
транзакции должны быть изолированы друг от друга, чтобы избежать конфликтов.

• Долговечность: Как только операция завершена, изменения должны быть сохранены в базе данных, даже если произойдет сбой.

Соблюдение свойств ACID критически важно для обеспечения надежности и целостности данных в системах управления базами данных.

---

### 7. Что такое нормализация и каковы ее преимущества? Объясните различные типы нормализации.

_Ответ_:

**Нормализация** — это процесс организации данных в реляционной базе данных с целью уменьшения избыточности и предотвращения аномалий обновления. 
Нормализация достигается путем разбиения больших таблиц на меньшие и определения отношений между ними. 
Этот процесс включает несколько этапов, называемых нормальными формами (НФ), каждая из которых имеет свои правила и требования.

#### Основные нормальные формы:

1. **Первая нормальная форма** (1НФ):

   • Все значения в столбцах должны быть атомарными (неделимыми).

   • Каждая строка должна быть уникальной, для чего обычно используется первичный ключ.

2. **Вторая нормальная форма** (2НФ):

   • Должна быть выполнена 1НФ.

   • Все неключевые атрибуты должны зависеть от всего первичного ключа, а не только от его части (для составных ключей).

3. **Третья нормальная форма** (3НФ):

   • Должна быть выполнена 2НФ.

   • Все неключевые атрибуты должны быть независимы друг от друга (не должно быть транзитивных зависимостей).

4. **Бойс-Кодд нормальная форма** (BCNF):

   • Более строгая версия 3НФ, в которой все зависимости функциональны должны зависеть от суперключа.

Существуют и более высокие нормальные формы, но 1НФ, 2НФ и 3НФ являются наиболее распространенными.

#### Преимущества нормализации:

1. Снижение избыточности данных:

   • Нормализация помогает избежать дублирования информации, что экономит место в базе данных и упрощает управление данными.

2. Упрощение обновлений:

   • Изменения в данных могут быть выполнены в одном месте, что минимизирует риск возникновения аномалий (например, аномалий вставки, обновления и удаления).

3. Улучшение целостности данных:

   • Нормализованные базы данных легче поддерживать в согласованном состоянии, поскольку правила целостности могут быть легче реализованы через ограничения и связи.

4. Легкость в обслуживании:

   • Структурированные данные проще анализировать и поддерживать, что упрощает процесс разработки и модификации базы данных.

5. Гибкость:

   • Нормализованные схемы позволяют легче добавлять новые данные или изменять существующие структуры без значительных затрат времени и ресурсов.

#### Недостатки нормализации:

Несмотря на преимущества, стоит отметить, что чрезмерная нормализация может привести к увеличению сложности 
запросов и ухудшению производительности из-за необходимости выполнения множества соединений между таблицами.
Поэтому важно находить баланс между нормализацией и производительностью базы данных, исходя из конкретных требований приложения.

---

### 8. Что вы подразумеваете под денормализацией?

_Ответ_:

Денормализация — это процесс изменения структуры базы данных с целью улучшения производительности чтения данных за счет увеличения избыточности.
Этот подход часто применяется в системах, где требуется высокая скорость доступа к данным, таких как системы отчетности или аналитические базы данных.

▎Основные аспекты денормализации:

1. Избыточность данных:

   • В процессе денормализации данные могут дублироваться в нескольких таблицах.
Это может привести к увеличению объема хранимых данных, но при этом ускоряет выполнение запросов, 
поскольку уменьшается количество соединений (JOIN) между таблицами.

2. Упрощение структуры данных:

   • Денормализация может включать объединение нескольких таблиц в одну, что упрощает структуру базы данных и позволяет быстрее извлекать данные.

3. Оптимизация производительности:

   • Основная цель денормализации — улучшить время отклика на запросы. Это особенно важно для систем, 
   где чтение данных происходит значительно чаще, чем их изменение.

4. Снижение количества соединений:

   • Денормализация может уменьшить необходимость в сложных операциях JOIN, что также способствует увеличению скорости выполнения запросов.

#### Примеры денормализации:

• Объединение таблиц: Вместо хранения информации о клиентах и заказах в отдельных таблицах, можно создать одну таблицу, 
которая будет содержать все необходимые данные о клиентах и их заказах.


• Добавление вычисляемых полей: Например, можно добавить поле с полным именем клиента 
в таблицу заказов вместо того, чтобы каждый раз извлекать его из таблицы клиентов.

• Кэширование: Хранение часто используемых агрегированных данных (например, суммы заказов по каждому клиенту) в отдельной таблице для ускорения доступа.

#### Недостатки денормализации:

1. Увеличение сложности управления данными:

   • Избыточность данных может усложнить операции обновления и удаления, так как необходимо следить за согласованностью данных в нескольких местах.

2. Риск возникновения ошибок:

   • При изменении данных в одной из таблиц может возникнуть несоответствие с дублирующимися данными в других таблицах.

3. Увеличение объема хранимых данных:

   • Денормализация может привести к значительному увеличению объема базы данных из-за дублирования информации.

---

### 9. Что такое индекс? Перечисли различные типы индексов, преимущества. В чем разница между кластеризованным и некластеризованным индексами в SQL?

_Ответ_:

Индекс — это структура данных, которая улучшает скорость выполнения операций поиска и сортировки в базе данных.
Индексы позволяют быстро находить строки в таблице, не просматривая всю таблицу, что значительно ускоряет выполнение запросов.
Индексы могут быть созданы на одном или нескольких столбцах таблицы.

1. Плоские (или простые) индексы:

   • Создаются на одном столбце таблицы.

   • Используются для ускорения поиска по этому столбцу.

2. Составные (или многоколонные) индексы:

   • Создаются на нескольких столбцах.

   • Используются для ускорения запросов, которые фильтруют или сортируют данные по нескольким столбцам одновременно.

3. Уникальные индексы:

   • Гарантируют уникальность значений в индексируемом столбце.

   • Используются для обеспечения целостности данных, например, для столбца с уникальными идентификаторами.

4. Полнотекстовые индексы:

   • Оптимизированы для поиска по текстовым данным.

   • Используются в запросах, где необходимо выполнять поиск по словам или фразам в больших текстах.

5. Индексы на основе выражений:

   • Создаются на результатах выражений или функций, а не на самих столбцах.

   • Полезны для ускорения запросов, которые используют вычисляемые значения.

6. **Индексы Б-деревьев** (B-tree):

   • Наиболее распространенный тип индекса.

   • Позволяет быстро выполнять операции поиска, вставки и удаления.

7. Индексы хеширования:

   • Используют хеш-функции для быстрого поиска.

   • Эффективны для точного поиска, но не поддерживают диапазонные запросы.

8. Индексы сжатия (compressed indexes):

   • Сжимаются для экономии места на диске.

   • Полезны в случаях, когда размер базы данных является критическим фактором.

9. Индексы с использованием географических данных (GIS):

   • Специальные индексы для работы с геопространственными данными.

   • Позволяют эффективно выполнять запросы по географическим координатам.

#### Преимущества индексов:

1. Ускорение операций поиска:

   • Индексы значительно снижают время выполнения запросов, особенно при работе с большими объемами данных.

2. Улучшение производительности сортировки:

   • Индексы могут ускорить сортировку данных, поскольку они уже хранятся в отсортированном виде.

3. Оптимизация операций соединения:

   • При соединении таблиц индексы могут помочь сократить количество строк, которые необходимо просмотреть.

4. Поддержка уникальности:

   • Уникальные индексы помогают обеспечить целостность данных и предотвращают дублирование.

5. Улучшение производительности агрегатных функций:

   • Индексы могут ускорить выполнение запросов с использованием агрегатных функций (например, SUM, COUNT).

#### Недостатки индексов:

1. Дополнительные затраты на хранение:

   • Индексы занимают дополнительное место на диске.

2. Замедление операций вставки, обновления и удаления:

   • При изменении данных в таблице необходимо обновлять соответствующие индексы, что может замедлить эти операции.

3. Сложность управления:

   • Необходимо следить за индексами и периодически их пересоздавать или оптимизировать.

#### Разница между кластеризованным и некластеризованным индексами в SQL

- Кластерный индекс используется для простого и быстрого извлечения данных из базы данных, тогда как чтение 
из некластеризованного индекса происходит относительно медленнее.

- Кластеризованный индекс изменяет способ хранения записей в базе данных — он сортирует строки по столбцу, который установлен
как кластеризованный индекс, тогда как в некластеризованном индексе он не меняет способ хранения, но создает отдельный объект внутри
таблицы, который указывает на исходные строки таблицы при поиске.

- Одна таблица может иметь только один кластеризованный индекс, тогда как некластеризованных у нее может быть много.

---

### 10. Что такое транзакция.

_Ответ_:

Транзакция в контексте баз данных — это последовательность операций, которые выполняются как единое целое. 
Транзакции обеспечивают целостность и согласованность данных, гарантируя, что все операции внутри транзакции 
будут выполнены успешно или ни одна из них не будет выполнена (в случае ошибки).

#### Основные характеристики транзакций:

1. Атомарность (Atomicity):

   • Транзакция должна быть атомарной, то есть либо все её операции выполняются, либо ни одна. 
   Если одна из операций завершилась с ошибкой, все изменения, внесенные до этого момента, должны быть отменены.

2. Согласованность (Consistency):

   • Транзакция должна переводить базу данных из одного согласованного состояния в другое. 
   Это означает, что все правила и ограничения целостности данных должны соблюдаться до и после выполнения транзакции.

3. Изолированность (Isolation):

   • Транзакции должны выполняться независимо друг от друга. Изменения, внесенные одной транзакцией, 
   не должны быть видны другим транзакциям, пока первая не завершится.

4. Долговечность (Durability):

   • После того как транзакция завершена, её результаты должны сохраняться даже в случае сбоя системы. 
   Это достигается с помощью механизмов журналирования и резервного копирования.

#### Типы транзакций:

1. Простые транзакции:

   • Состоят из одной или нескольких операций, которые выполняются как единое целое. 
   Например, перевод денег с одного банковского счета на другой может включать операции снятия средств с одного счета и зачисления на другой.

2. Сложные транзакции:

   • Включают более сложные бизнес-логики и могут затрагивать несколько систем или баз данных. 
   Например, обработка заказа может включать проверку наличия товаров на складе, резервирование товаров и обновление информации о клиенте.

3. Распространенные транзакции:

   • Это транзакции, которые выполняются в рамках стандартных операций, таких как вставка, обновление или удаление записей в таблицах базы данных.

4. Распределенные транзакции:

   • Эти транзакции охватывают несколько баз данных или систем. Они требуют координации 
   между различными системами для обеспечения атомарности и согласованности.

5. Долгосрочные транзакции:

   • Такие транзакции могут занимать продолжительное время для выполнения и часто требуют механизма управления состоянием для отслеживания их прогресса.

#### Примеры использования транзакций:

• Банковские операции: Перевод средств между счетами требует выполнения нескольких операций (снятие и зачисление), которые должны быть атомарными.

• Электронная коммерция: При оформлении заказа необходимо обновить информацию о товарах на складе и данные о клиенте.

• Управление запасами: При добавлении новых товаров в инвентарь необходимо обновить несколько таблиц (товары, поставщики и т.д.).

#### В PostgreSQL

В PostgreSQL транзакции можно классифицировать по различным критериям. Вот основные виды транзакций и связанные с ними концепции:

▎1. Обычные транзакции (Standard Transactions)

Это базовые транзакции, которые начинаются с команды BEGIN и завершаются командой COMMIT или ROLLBACK. 
Все операции между этими командами выполняются как единое целое.

▎2. Автоматические транзакции (Implicit Transactions)

В PostgreSQL каждая отдельная команда, такая как INSERT, UPDATE или DELETE, выполняется в своей собственной 
транзакции, если не была явно начата другая транзакция. Это называется неявной транзакцией.

▎3. Распределенные транзакции (Distributed Transactions)

Эти транзакции охватывают несколько баз данных или серверов. PostgreSQL поддерживает распределенные транзакции 
через протокол Two-Phase Commit (2PC), который обеспечивает согласованность данных между различными системами.

▎4. Долгосрочные транзакции (Long-Lived Transactions)

Транзакции, которые могут занимать продолжительное время для выполнения. В PostgreSQL такие транзакции могут 
быть сложными, особенно если они требуют блокировок ресурсов на длительный срок.

▎5. Параллельные транзакции (Concurrent Transactions)

Несколько транзакций могут выполняться одновременно, и PostgreSQL использует механизмы управления 
конкурентным доступом (например, MVCC - Multi-Version Concurrency Control), чтобы обеспечить изолированность и согласованность данных.

▎6. Транзакции с использованием уровней изоляции (Transactions with Isolation Levels)

PostgreSQL поддерживает различные уровни изоляции транзакций, которые определяют, как изменения, внесенные 
одной транзакцией, видны другим. Уровни изоляции включают:

• Read Uncommitted: Позволяет читать незавершенные изменения других транзакций (не поддерживается в PostgreSQL).

• Read Committed: Позволяет видеть только завершенные изменения.

• Repeatable Read: Гарантирует, что все чтения в рамках транзакции будут возвращать одни и те же данные.

• Serializable: Самый строгий уровень изоляции, который предотвращает любые конфликты между параллельными транзакциями.

▎7. Транзакции с использованием точек сохранения (Savepoints)

Позволяют создавать промежуточные точки внутри транзакции. Это полезно для частичного отката изменений без отмены всей транзакции.

▎8. Транзакции с использованием временных таблиц (Temporary Tables)

Транзакции, которые работают с временными таблицами, создаваемыми в рамках текущей сессии и автоматически удаляемыми после её завершения.

---

### 11. Что такое первичный ключ и внешний ключ?

_Ответ_:

**Первичный ключ** (PRIMARY KEY):
- Уникальный идентификатор записи в таблице.
- Не допускает дубликатов и NULL значений.
- Может состоять из одного или нескольких столбцов (составной ключ).

```sql
CREATE TABLE students (
student_id INT PRIMARY KEY,
name VARCHAR(100),
age INT
);
```

**Внешний ключ** (FOREIGN KEY):
- Столбец или набор столбцов, которые ссылаются на первичный ключ другой таблицы.
- Обеспечивает ссылочную целостность между таблицами.
- Позволяет связать записи из разных таблиц.

```sql
CREATE TABLE enrollments (
enrollment_id INT PRIMARY KEY,
student_id INT,
course_id INT,
FOREIGN KEY (student_id) REFERENCES students(student_id),
FOREIGN KEY (course_id) REFERENCES courses(course_id)
);
```

---

### 12. Что такое JOIN и какие виды JOIN вы знаете?

_Ответ_:

**JOIN** — это операция в SQL, которая позволяет объединить строки из двух или более таблиц на основе связанных между ними столбцов.

![img.png](img.png)

**Inner join** (Внутреннее соединение): Оно используется для возврата всех строк из нескольких таблиц, для которых выполняется условие соединения.

**Left Join** (Левое соединение): используется для возврата всех строк из левой (первой) таблицы и 
только совпадающих строк из правой (второй) таблицы, для которых выполняется условие соединения.

**Right Join** (Правое соединение): используется для возврата всех строк из правой (второй) таблицы и 
только совпадающих строк из левой (первой) таблицы, для которых выполняется условие соединения.

**Full Join** (Полное соединение): возвращает все записи, для которых есть совпадение в любой из таблиц. 
Следовательно, он возвращает все строки из левой таблицы и все строки из правой таблицы.

---

### 13. Что такое ограничения (Constraints)?

_Ответ_:

Ограничения (constraints) в базе данных — это правила, которые применяются к столбцам и таблицам для обеспечения целостности и корректности данных.
Они помогают гарантировать, что данные, вводимые в таблицы, соответствуют определённым условиям и требованиям.

#### Основные типы ограничений:

▎1. PRIMARY KEY

Это ограничение используется для определения уникального идентификатора для каждой строки в таблице. 
Поля, помеченные как PRIMARY KEY, не могут содержать NULL-значения и должны быть уникальными.

▎2. FOREIGN KEY

Ограничение внешнего ключа устанавливает связь между двумя таблицами. Оно гарантирует, что значения в 
одном столбце (или группе столбцов) соответствуют значениям в другом столбце (или группе столбцов) в 
другой таблице. Это помогает поддерживать ссылочную целостность.

▎3. UNIQUE

Это ограничение гарантирует, что все значения в указанном столбце (или группе столбцов) уникальны. 
В отличие от PRIMARY KEY, UNIQUE может допускать NULL-значения, но только одно NULL-значение в случае одного столбца.

▎4. CHECK

Ограничение CHECK позволяет задать условие, которое должно выполняться для значений в столбце. 
Например, можно установить правило, что возраст должен быть больше 0.

▎5. NOT NULL

Это ограничение запрещает наличие NULL-значений в указанном столбце. Если столбец помечен как NOT NULL, 
то при вставке или обновлении данных необходимо предоставлять значение.

▎6. EXCLUDE

Это ограничение используется для обеспечения уникальности значений в определённых условиях, особенно в 
контексте пространственных данных. Оно позволяет задавать более сложные условия уникальности, чем просто уникальные значения.

#### Примеры использования ограничений

```sql
CREATE TABLE employees (
id SERIAL PRIMARY KEY,
name VARCHAR(100) NOT NULL,
age INT CHECK (age > 0),
department_id INT,
FOREIGN KEY (department_id) REFERENCES departments(id),
UNIQUE (name)
);
```

В этом примере:

• id — первичный ключ.
• name не может быть NULL.
• age должен быть больше 0.
• department_id является внешним ключом, ссылающимся на id в таблице departments.
• name должен быть уникальным.

#### Зачем нужны ограничения?

1. Целостность данных: Ограничения помогают предотвратить ввод некорректных или противоречивых данных.

2. Упрощение управления данными: Они автоматизируют проверку данных, что уменьшает необходимость ручной проверки.

3. Улучшение производительности: Некоторые ограничения могут помочь оптимизировать запросы и индексацию.

---

### 14. Что такое Self JOIN?

_Ответ_:

Self JOIN — это тип соединения в SQL, который позволяет объединить таблицу саму с собой. Это может быть 
полезно, когда необходимо сравнить строки в одной и той же таблице или когда требуется извлечь данные, основанные на взаимосвязи между строками.

#### Когда использовать Self JOIN?

Self JOIN может использоваться в различных сценариях, например:

• Для нахождения связанных записей в одной таблице.
• Для создания иерархических структур, таких как категории и подкатегории.
• Для поиска дубликатов.

#### Пример Self JOIN

Рассмотрим таблицу employees, которая содержит информацию о сотрудниках, включая их идентификаторы и идентификаторы менеджеров:

```sql
CREATE TABLE employees (
id SERIAL PRIMARY KEY,
name VARCHAR(100),
manager_id INT
);
```

Предположим, что в таблице есть следующие данные:

| id | name      | manager_id |
|----|-----------|------------|
| 1  | Alice     | NULL       |
| 2  | Bob       | 1          |
| 3  | Charlie   | 1          |
| 4  | David     | 2          |
| 5  | Eve       | 2          |

Теперь мы хотим получить список сотрудников вместе с именами их менеджеров. Для этого мы можем использовать Self JOIN:

```sql
SELECT
e1.name AS employee_name,
e2.name AS manager_name
FROM
employees e1
LEFT JOIN
employees e2 ON e1.manager_id = e2.id;
```

#### Результат запроса

Этот запрос вернёт следующую таблицу:

| employeename | managername |
|---------------|--------------|
| Alice         | NULL         |
| Bob           | Alice        |
| Charlie       | Alice        |
| David         | Bob          |
| Eve           | Bob          |

• В данном запросе мы используем два алиаса для одной и той же таблицы: e1 для сотрудников и e2 для менеджеров.
• Мы соединяем таблицу employees сама с собой, используя условие ON e1.manager_id = e2.id, что позволяет нам сопоставить каждого сотрудника с его менеджером.
• Использование LEFT JOIN позволяет также получить сотрудников, у которых нет менеджера (например, Alice).

---

### 15. Для чего нужен оператор UNION? Объясните разницу между UNION и UNION ALL.

_Ответ_:

Оператор UNION в SQL используется для объединения результатов двух или более запросов SELECT. 
Он позволяет комбинировать результаты, возвращаемые разными запросами, в одну результирующую таблицу. 
При этом важно, чтобы все объединяемые запросы имели одинаковое количество столбцов и совместимые типы данных.

#### Основные характеристики оператора UNION:

1. Уникальные строки: UNION автоматически удаляет дубликаты из результирующего набора. 
То есть, если один и тот же результат появляется в нескольких запросах, он будет отображен только один раз.

2. Структура: Все объединяемые запросы должны иметь одинаковое количество столбцов, и типы данных в соответствующих столбцах должны быть совместимыми.

#### Пример использования UNION

Предположим, у нас есть две таблицы: employees и contractors, которые содержат информацию о работниках и подрядчиках соответственно.
Мы хотим получить список всех людей, работающих в компании.

```sql
SELECT name FROM employees
UNION
SELECT name FROM contractors;
```

Этот запрос вернет уникальные имена из обеих таблиц.

#### Разница между UNION и UNION ALL

**UNION**:
• Удаляет дубликаты.
• Может занимать больше времени для выполнения, так как требуется дополнительная обработка для удаления дубликатов.

**UNION ALL**:
• Сохраняет все строки, включая дубликаты.
• Обычно выполняется быстрее, так как не требует обработки для удаления дубликатов.

#### Пример использования UNION ALL

Если мы хотим получить полный список имен, включая дубликаты, мы можем использовать UNION ALL:

```sql
SELECT name FROM employees
UNION ALL
SELECT name FROM contractors;
```

Этот запрос вернет все имена из обеих таблиц, включая те, которые встречаются в обеих таблицах.

Используйте UNION, когда вам нужны уникальные результаты.
Используйте UNION ALL, когда вам нужно сохранить все результаты, включая дубликаты, и вам важна производительность.

---

### 16. Что такое триггеры в SQL?

_Ответ_:

Триггер — это хранимая процедура, которая автоматически выполняется при наступлении определенного события в базе данных, такого как INSERT, UPDATE или DELETE на определенной таблице.

#### Типы триггеров:
- DML триггеры: реагируют на операции INSERT, UPDATE, DELETE.
- DDL триггеры: реагируют на операции CREATE, ALTER, DROP.
- Триггеры уровня строки или оператора.

#### Преимущества триггеров:
- Автоматизация проверок и ограничений.
- Логирование изменений.
- Поддержание целостности данных.

Пример создания триггера:

```sql
CREATE TRIGGER trg_after_insert_employee
AFTER INSERT ON employees
FOR EACH ROW
BEGIN
    INSERT INTO audit_log (employee_id, action, action_time)
    VALUES (NEW.id, 'INSERT', NOW());
END;
```

---

### 17. Объясните разницу между WHERE и HAVING

_Ответ_:

**WHERE**
- Фильтрует строки до группировки данных.
- Не может использовать агрегатные функции (SUM(), COUNT(), AVG(), и т.д.).
- Применяется к отдельным записям таблицы.  

#### Пример:

```sql
SELECT department_id, COUNT(*)
FROM employees
WHERE salary > 50000
GROUP BY department_id;
```

**HAVING**

- Фильтрует группы строк после группировки данных.
- Может использовать агрегатные функции. 
- Применяется к результатам GROUP BY.

#### Пример:

```sql
SELECT department_id, COUNT(*) AS num_employees
FROM employees
GROUP BY department_id
HAVING COUNT(*) > 5;
```

---

### 18. Каковы основные различия между DELETE и TRUNCATE?

_Ответ_:

**DELETE**:

- Удаляет выбранные записи из таблицы.
- Можно использовать условие WHERE для удаления конкретных записей.
- Операция записывается в журнал транзакций построчно.
- Триггеры ON DELETE срабатывают.
- Медленнее по сравнению с TRUNCATE.

#### Пример:

```sql
DELETE FROM employees WHERE salary < 30000;
```

**TRUNCATE**:

- Удаляет все записи из таблицы без возможности восстановления через ROLLBACK (в большинстве СУБД).
- Нельзя использовать WHERE.
- Операция быстрее, так как не логируется построчно.
- Сбрасывает идентификаторы (если используется автоинкремент).
- Триггеры не срабатывают.

#### Пример:

```sql
TRUNCATE TABLE employees;
```

---

### 19. Что такое подзапрос (subquery) и когда он используется?

_Ответ_:

Подзапрос — это SQL-запрос, вложенный внутри другого запроса. Он используется для выполнения операций, результат которых необходим для основного запроса.

#### Случаи использования подзапросов:
- Фильтрация данных: Использование результатов подзапроса в условиях WHERE или HAVING.
- Выборка данных: Использование подзапроса в списке выбранных столбцов.
- Создание виртуальных таблиц: Использование подзапроса в операторе FROM.

#### Примеры:
Подзапрос в WHERE:
```sql
SELECT name
FROM employees
WHERE department_id = (SELECT id FROM departments WHERE name = 'IT');
```

Подзапрос в FROM:

```sql
SELECT sub.department, COUNT(*)
FROM (
    SELECT department_id AS department
    FROM employees
) sub
GROUP BY sub.department;
```

---

### 20. Как использовать оператор LIKE и для чего он применяется?

_Ответ_:

Оператор LIKE используется в условиях WHERE для поиска строк, соответствующих определенному шаблону. В шаблонах используются подстановочные символы:

- % — соответствует любой последовательности символов (включая нулевую длину).
- _ — соответствует одному любому символу.

#### Примеры использования:

Поиск строк, начинающихся с «А»:

```sql
SELECT * FROM employees WHERE name LIKE 'А%';
```

Поиск строк, оканчивающихся на «e»:

```sql
SELECT * FROM employees WHERE name LIKE '%e';
```

Поиск строк, где второй символ — «a»:

```sql
SELECT * FROM employees WHERE name LIKE '_а%';
```

---

### 21. Что такое агрегатные функции? Приведите примеры

_Ответ_:

Агрегатные функции выполняют вычисления над набором значений и возвращают одно значение. Они часто используются в сочетании с оператором GROUP BY.

#### Основные агрегатные функции
- COUNT() — подсчитывает количество строк.
- SUM() — вычисляет сумму значений.
- AVG() — вычисляет среднее значение.
- MAX() — находит максимальное значение.
- MIN() — находит минимальное значение.

#### Примеры использования

Подсчет количества сотрудников:

```sql
SELECT COUNT(*) FROM employees;
```

Средняя зарплата по отделам:

```sql
SELECT department_id, AVG(salary) AS average_salary
FROM employees
GROUP BY department_id;
```

Максимальная зарплата в компании:

```sql
SELECT MAX(salary) FROM employees;
```

Суммарные продажи за месяц:

```sql
SELECT SUM(amount) FROM sales WHERE sale_date BETWEEN '2023-01-01' AND '2023-01-31';
```

---

### 22. Что такое NULL и как с ним работать в SQL?

_Ответ_:

NULL — это специальное значение в SQL, обозначающее отсутствие данных или неизвестное значение.

#### Особенности NULL:
- NULL не эквивалентно пустой строке или нулю.
- Операции с NULL возвращают NULL.
- Сравнение NULL = NULL возвращает FALSE.

#### Работа с NULL

Для проверки на NULL используется оператор IS NULL или IS NOT NULL.

```sql
-- Поиск записей с неизвестной датой рождения
SELECT * FROM employees WHERE birth_date IS NULL;

-- Поиск записей с известной датой рождения
SELECT * FROM employees WHERE birth_date IS NOT NULL;
```

---

### 23. Что такое хранимая процедура и как она отличается от функции?

_Ответ_:

#### Хранимая процедура (Stored Procedure):
- Набор SQL-команд, сохраненных на сервере для повторного использования.
- Может выполнять операции SELECT, INSERT, UPDATE, DELETE.
- Может возвращать несколько наборов результатов или ничего не возвращать.
- Может иметь входные и выходные параметры.
- Не может быть вызвана внутри SQL-запроса.

#### Пример хранимой процедуры:

```sql
CREATE PROCEDURE GetEmployeeByID(IN emp_id INT)
BEGIN
    SELECT * FROM employees WHERE id = emp_id;
END;
```

#### Вызов процедуры:

```sql
CALL GetEmployeeByID(1);
```

#### Функция (Function):
Возвращает одно значение (скалярная функция) или таблицу (табличная функция).
Может использоваться в SQL-выражениях (например, в SELECT или WHERE).
Должна возвращать значение.
Обычно используется для вычислений и возвращает детерминированный результат.

#### Пример функции:

```sql
CREATE FUNCTION GetEmployeeSalary(emp_id INT) RETURNS DECIMAL(10,2)
BEGIN
    DECLARE salary DECIMAL(10,2);
    SELECT e.salary INTO salary FROM employees e WHERE e.id = emp_id;
    RETURN salary;
END;
```

#### Использование функции:

```sql
SELECT name, GetEmployeeSalary(id) FROM employees;
```

---

### 24. Как удалить дубликаты в результате SQL-запроса?

_Ответ_:

Использовать ключевое слово DISTINCT в операторе SELECT, чтобы вернуть только уникальные записи.

Пример:

```sql
SELECT DISTINCT position
FROM employees;
```

---

### 25. Объясните, что такое VIEW и его преимущества

_Ответ_:

**VIEW** (представление) — это виртуальная таблица, основанная на результате SQL-запроса.
Представление не хранит данные самостоятельно, а предоставляет определенный способ просмотра данных из одной или нескольких таблиц.

#### Преимущества VIEW:
- Упрощение сложных запросов: позволяет сохранить сложный запрос и использовать его как простую таблицу.
- Безопасность: предоставляет пользователям доступ только к определенным данным, скрывая остальные.
- Обновляемость: в некоторых случаях можно обновлять данные через представление.
- Поддержание целостности данных: может содержать данные из нескольких таблиц, объединенные определенным образом.

#### Пример создания VIEW:

```sql
CREATE VIEW employee_details AS
SELECT e.id, e.name, d.name AS department, e.salary
FROM employees e
JOIN departments d ON e.department_id = d.id;
```

Использование VIEW:

```sql
SELECT * FROM employee_details WHERE salary > 50000;
```

---

### 26. Как использовать оператор CASE в SQL?

_Ответ_:

Оператор CASE используется для реализации условной логики в SQL-запросах. Он позволяет возвращать значения на основе условий, подобно оператору ```IF-ELSE```.

```sql
CASE
    WHEN condition1 THEN result1
    WHEN condition2 THEN result2
    ...
    ELSE default_result
END
```

#### Примеры

Присвоение категорий на основе зарплаты:

```sql
SELECT name,
    salary,
    CASE
        WHEN salary >= 80000 THEN 'Высокая'
        WHEN salary >= 50000 THEN 'Средняя'
        ELSE 'Низкая'
    END AS salary_category
FROM employees;
```

---

### 27. Объясните транзакционные команды COMMIT и ROLLBACK.

_Ответ_:

**COMMIT**

- Фиксирует текущую транзакцию.
- Все изменения, сделанные в транзакции, становятся постоянными и видимыми для других пользователей.
- После COMMIT отменить изменения нельзя.

```sql
BEGIN TRANSACTION;

UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;

COMMIT;
```

**ROLLBACK**

- Отменяет текущую транзакцию.
- Все изменения, сделанные в транзакции, откатываются.
- База данных возвращается в состояние до начала транзакции.

```sql
BEGIN TRANSACTION;

DELETE FROM orders WHERE order_date < '2022-01-01';

-- Если передумали
ROLLBACK;
```

#### Использование в управлении транзакциями:
- BEGIN TRANSACTION или START TRANSACTION: начало транзакции.
- COMMIT: фиксация транзакции
- ROLLBACK: откат транзакции.

---

### 28. Объясните различия между CHAR и VARCHAR

_Ответ_:

**CHAR** (n):

- Хранит строки фиксированной длины n.
- Если введенная строка короче n, она дополняется пробелами до длины n.
- Используется для хранения данных одинаковой длины (например, коды стран, почтовые индексы).

**VARCHAR**(n):

- Хранит строки переменной длины до n символов.
- Фактически занимает столько места, сколько символов в строке плюс небольшой служебный объем для хранения длины.
- Используется для хранения строковых данных переменной длины.

#### Основные различия:

Память и производительность:

- CHAR всегда занимает фиксированное количество памяти.
- VARCHAR более эффективен с точки зрения использования памяти, но может быть немного медленнее при доступе.

Применение:

- CHAR подходит для данных с предсказуемой длиной.
- VARCHAR подходит для данных переменной длины.

#### Пример:

```sql
CREATE TABLE products (
    code CHAR(10),     -- Код товара фиксированной длины
    name VARCHAR(100)  -- Название товара переменной длины
);
```

Вставка данных:

```sql
INSERT INTO products (code, name)
VALUES ('A123', 'Ноутбук Lenovo');
```

В столбце code значение будет дополненно пробелами до 10 символов.

---

### 29. Как работают команды REVOKE и GRANT?

_Ответ_:

Команды GRANT и REVOKE в SQL используются для управления правами доступа пользователей к объектам базы данных.
Они позволяют предоставлять или отзывать определенные привилегии у пользователей или ролей, обеспечивая безопасность и
контроль над тем, кто и какие действия может выполнять в базе данных.

**GRANT**

Команда GRANT предоставляет пользователям или ролям определенные привилегии на объекты базы данных.

Синтаксис:

```sql
GRANT privileges ON object TO user [WITH GRANT OPTION];
```

- privileges: действия, которые разрешено выполнять (например, SELECT, INSERT, UPDATE, DELETE, ALL PRIVILEGES).
- object: база данных, таблица, представление, процедура и т.д.
- user: имя пользователя или роли, которой предоставляются права.
- WITH GRANT OPTION (опционально): позволяет получателю привилегий передавать их другим пользователям.

#### Пример:

Предоставить пользователю user1 право выбора данных из таблицы employees можно следующим способом:

```sql
GRANT SELECT ON employees TO user1;
```

**REVOKE**

Команда REVOKE отзывает ранее предоставленные привилегии у пользователей или ролей.

Синтаксис:

```sql
REVOKE privileges ON object FROM user;
```

#### Пример:

Отозвать у пользователя user1 право выбора данных из таблицы employees:

```sql
REVOKE SELECT ON employees FROM user1;
```

---

### 30. Что такое SQL-инъекция и как от нее защититься?

_Ответ_:

SQL-инъекция — это метод атаки на базу данных, при котором злоумышленник вставляет 
вредоносный SQL-код через вводимые данные, позволяя выполнять несанкционированные SQL-запросы.

#### Последствия SQL-инъекции:

- Кража данных.
- Удаление или изменение данных.
- Получение административного доступа.

#### Способы защиты от SQL-инъекций:

1. Параметризированные запросы (Prepared Statements):

- Использование параметров вместо конкатенации строк.
- СУБД автоматически экранирует специальные символы.

Пример (на языке Java с использованием JDBC)

```sql
String sql = "SELECT * FROM users WHERE username = ? AND password = ?";
PreparedStatement stmt = connection.prepareStatement(sql);
stmt.setString(1, username);
stmt.setString(2, password);
ResultSet rs = stmt.executeQuery();
```

2. Использование ORM (Object-Relational Mapping):

- Библиотеки ORM часто включают механизмы защиты от SQL-инъекций.

3. Проверка и фильтрация вводимых данных:

- Проверять данные на соответствие ожидаемому формату.
- Использовать валидацию на стороне сервера и клиента.

4. Ограничение прав доступа:

- Предоставлять минимально необходимые права пользователям базы данных.
- Ограничить доступ к системным таблицам и операциям.

5. Использование хранимых процедур:

- Логика работы с данными инкапсулирована в процедуре.
- Пользователи имеют доступ только к процедурам, а не к таблицам напрямую.

---

### 31. Как оптимизировать производительность SQL-запросов?

_Ответ_:

#### Использовать индексы:

- Создавайте индексы на столбцах, часто используемых в условиях WHERE, JOIN и ORDER BY.
- Избегайте избыточных индексов.

#### Избегать SELECT *:

- Выбирайте только необходимые столбцы.
- Уменьшает объем передаваемых данных.

#### Оптимизировать условия JOIN и WHERE:

- Используйте равенство (=) вместо неравенства, где возможно.
- Избегайте функций и вычислений над индексируемыми столбцами в условиях.

#### Использовать ограничения результатов (LIMIT):

- Ограничивайте количество возвращаемых строк, если не нужны все данные.

#### Избегать подзапросов, где возможны соединения:

- Заменяйте коррелированные подзапросы на JOIN или EXISTS.

#### Кеширование часто используемых данных:

- Используйте материализованные представления или кеширование на уровне приложения.

#### Профилирование и анализ запросов:

- Используйте инструменты (EXPLAIN, EXPLAIN PLAN) для анализа плана выполнения запросов.

---
